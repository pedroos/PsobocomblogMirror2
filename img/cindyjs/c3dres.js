/** @enum {string} */
var c3d_resources={
"common_frag":"uniform mat4 uProjectionMatrix;\r\n\r\nvec3 sphere(in vec3 ray,in vec3 center,in float radius,in float face){\r\n\r\nvec3 dir=normalize(ray);\r\n\r\n\r\n\r\n\r\nfloat b=dot(center,dir);\r\nfloat c=dot(center,center) -radius*radius;\r\nfloat d=b*b-c;\r\nif(d<0.0)discard;\r\nfloat lambda=b+face*sqrt(d);\r\nif(lambda<0.0)discard;\r\n\r\n\r\nreturn lambda*dir;\r\n}\r\n\r\nvoid finish(in vec3 pos,in vec3 normal){\r\nshade(pos,normal);\r\n#ifdef GL_EXT_frag_depth\r\nvec4 projPoint=uProjectionMatrix*vec4(pos,1);\r\ngl_FragDepthEXT= (projPoint.z/projPoint.w+1.0) /2.0;\r\n#endif\r\n#ifdef webgl2\r\nvec4 projPoint=uProjectionMatrix*vec4(pos,1);\r\ngl_FragDepth= (projPoint.z/projPoint.w+1.0) /2.0;\r\n#endif\r\n}\r\n",
"cylinder_frag":"varying vec3 vPoint1;\r\n\r\nvarying vec3 vPoint2;\r\n\r\nvarying vec3 vPos;\r\n\r\nvarying float vRadius;\r\n\r\nvec3 endcaps(in float mu,inout vec3 pos){\r\nvec3 center;\r\nif(mu<0.0){\r\ncenter=vPoint1;\r\n}else if(mu>1.0){\r\ncenter=vPoint2;\r\n}else{\r\nreturn(1.0-mu)*vPoint1+mu*vPoint2;\r\n}\r\npos=sphere(vPos,center,vRadius, -1.0);\r\nreturn center;\r\n}\r\n\r\n\r\n\r\n\r\nvoid main(){\r\ngColor=vColor;\r\n\r\n\r\n\r\nvec3 ba=vPoint2-vPoint1;\r\nvec3 u=ba/dot(ba,ba);\r\nvec3 v=vPos-dot(vPos,ba)*u;\r\nvec3 w=dot(vPoint1,ba)*u-vPoint1;\r\nfloat a=dot(v,v);\r\nfloat b=2.0*dot(v,w);\r\nfloat c=dot(w,w) -vRadius*vRadius;\r\nfloat d=b*b-4.0*a*c;\r\nif(d<0.0)\r\ndiscard;\r\nfloat lambda= (b+sqrt(d))/(-2.0*a);\r\nvec3 pointOnSurface=lambda*vPos;\r\nfloat mu=dot(pointOnSurface-vPoint1,u);\r\nvec3 center=endcaps(mu,pointOnSurface);\r\nvec3 normal=normalize(pointOnSurface-center);\r\nfinish(pointOnSurface,normal);\r\n}\r\n",
"cylinder_vert":"uniform mat4 uProjectionMatrix;\r\n\r\nuniform mat4 uModelViewMatrix;\r\n\r\nattribute vec4 aPoint1;\r\n\r\nattribute vec4 aPoint2;\r\n\r\nattribute vec4 aColor;\r\n\r\nattribute vec4 aRelativeRadius;\r\n\r\nattribute vec4 aShininess;\r\n\r\nvarying vec3 vPoint1;\r\n\r\nvarying vec3 vPoint2;\r\n\r\nvarying vec3 vPos;\r\n\r\nvarying vec4 vColor;\r\n\r\nvarying float vRadius;\r\n\r\n\r\n\r\n\r\nvoid main(){\r\n\r\nvec4 hom;\r\nhom=uModelViewMatrix*aPoint1;\r\nvPoint1=hom.xyz/hom.w;\r\nhom=uModelViewMatrix*aPoint2;\r\nvPoint2=hom.xyz/hom.w;\r\nvec3 dir=normalize(vPoint2-vPoint1);\r\n\r\n\r\nvec3 d2,d3;\r\nif(abs(dir.x) <abs(dir.y))\r\nd2=vec3(1,0,0);\r\nelse\r\nd2=vec3(0,1,0);\r\nd2=normalize(cross(dir,d2));\r\nd3=normalize(cross(dir,d2));\r\n\r\nvPos=aRelativeRadius.w*(mat3(dir,d2,d3)*aRelativeRadius.xyz)\r\n+0.5*((vPoint2+vPoint1) +aRelativeRadius.x*(vPoint2-vPoint1));\r\n\r\n\r\nvColor=aColor;\r\nvShininess=aShininess.x;\r\nvSpecularReflectiveness= (1.0-pow(0.95,vShininess));\r\nvRadius=aRelativeRadius.w;\r\n\r\n\r\ngl_Position=uProjectionMatrix*vec4(vPos,1);\r\n}\r\n",
"lighting1":"uniform vec3 uAmbient;\r\nuniform mat4 uModelViewMatrix;\r\n\r\nvarying vec4 vColor;\r\nvarying float vShininess;\r\nvarying float vSpecularReflectiveness;\r\n\r\nvec4 gColor;\r\nvec3 gPos;\r\nvec3 gEye;\r\nvec3 gNormal;\r\nvec3 gAccumDiffuse;\r\nvec3 gAccumSpecular;\r\n\r\nvoid commonLight(in vec4 lightPos,out vec3 lightDir,\r\nout float diffuseFactor,out float specularFactor){\r\nvec3 halfVector;\r\nfloat specularDot;\r\n\r\nlightDir=normalize(lightPos.xyz-lightPos.w*gPos);\r\nhalfVector=normalize(lightDir+gEye);\r\ndiffuseFactor=max(0.0,dot(gNormal,lightDir));\r\nspecularDot=max(0.0,dot(gNormal,halfVector));\r\n\r\n\r\nif(diffuseFactor==0.0)\r\nspecularFactor=0.0;\r\nelse\r\nspecularFactor=pow(specularDot,vShininess) *vSpecularReflectiveness;\r\n}\r\n\r\nvec4 flipY(in vec4 v){\r\nreturn vec4(v.x, -v.y,v.z,v.w);\r\n}\r\n\r\nvoid pointLight(in vec4 lightPos,in vec3 diffuse,in vec3 specular){\r\nvec3 lightDir;\r\nfloat diffuseFactor;\r\nfloat specularFactor;\r\n\r\ncommonLight(lightPos,lightDir,diffuseFactor,specularFactor);\r\n\r\n\r\ngAccumDiffuse +=diffuse*diffuseFactor;\r\ngAccumSpecular+=specular*specularFactor;\r\n}\r\n\r\nvoid cameraPointLight(in vec4 lightPos,in vec3 diffuse,in vec3 specular){\r\npointLight(flipY(lightPos),diffuse,specular);\r\n}\r\n\r\nvoid worldPointLight(in vec4 lightPos,in vec3 diffuse,in vec3 specular){\r\npointLight(-uModelViewMatrix*lightPos,diffuse,specular);\r\n}\r\n\r\nvoid spotLight(\r\nin vec4 lightPos,in vec4 spotPos,in float spotCosCutoff,\r\nin float spotExponent,in vec3 diffuse,in vec3 specular)\r\n{\r\nvec3 lightDir;\r\nfloat diffuseFactor;\r\nfloat specularFactor;\r\nvec3 spotDir;\r\nfloat spotCosAngle;\r\nfloat spotAttenuation;\r\n\r\ncommonLight(lightPos,lightDir,diffuseFactor,specularFactor);\r\n\r\nspotDir=lightPos.w*spotPos.xyz-spotPos.w*lightPos.xyz;\r\nspotCosAngle=dot(-lightDir,normalize(spotDir));\r\nspotAttenuation=\r\nstep(spotCosCutoff,spotCosAngle) *pow(spotCosAngle,spotExponent);\r\n\r\n\r\ngAccumDiffuse +=spotAttenuation*diffuse*diffuseFactor;\r\ngAccumSpecular+=spotAttenuation*specular*specularFactor;\r\n}\r\n\r\nvoid cameraSpotLight(\r\nin vec4 lightPos,in vec4 spotPos,in float spotCosCutoff,\r\nin float spotExponent,in vec3 diffuse,in vec3 specular)\r\n{\r\nspotLight(\r\nflipY(lightPos),flipY(spotPos),\r\nspotCosCutoff,spotExponent,diffuse,specular);\r\n}\r\n\r\nvoid worldSpotLight(\r\nin vec4 lightPos,in vec4 spotPos,in float spotCosCutoff,\r\nin float spotExponent,in vec3 diffuse,in vec3 specular)\r\n{\r\nspotLight(\r\n-uModelViewMatrix*lightPos, -uModelViewMatrix*spotPos,\r\nspotCosCutoff,spotExponent,diffuse,specular);\r\n}\r\n",
"lighting2":"\r\n\r\n\r\n\r\n\r\n\r\nvoid shade(in vec3 position,in vec3 normal){\r\n\r\ngAccumDiffuse=vec3(0.0);\r\ngAccumSpecular=vec3(0.0);\r\n\r\n\r\ngPos=position;\r\ngEye= -normalize(position);\r\ngNormal=sign(dot(gEye,normal))*normal;\r\n\r\n\r\nlightScene();\r\n\r\n\r\n\r\nvec3 color= (uAmbient+gAccumDiffuse) *gColor.xyz\r\n+gAccumSpecular;\r\n\r\ncolor=clamp(color,0.0,1.0);\r\ngl_FragColor=vec4(color.xyz,gColor.w);\r\n}\r\n",
"sphere_frag":"\r\nuniform float sphereMode;\r\n\r\n\r\nvarying vec3 vViewSpacePos;\r\n\r\nvarying vec3 vViewSpaceCenter;\r\n\r\nvarying float vRadius;\r\n\r\n\r\n\r\n\r\nvoid main(){\r\ngColor=vColor;\r\nvec3 pointOnSphere=\r\nsphere(vViewSpacePos,vViewSpaceCenter,vRadius,sphereMode);\r\nvec3 normal=normalize(pointOnSphere-vViewSpaceCenter);\r\nfinish(pointOnSphere,normal);\r\n}\r\n",
"sphere_vert":"uniform mat4 uProjectionMatrix;\r\n\r\nuniform mat4 uModelViewMatrix;\r\n\r\nattribute vec4 aCenter;\r\n\r\nattribute vec4 aColor;\r\n\r\nattribute vec4 aRelativeShininessRadius;\r\n\r\nvarying vec3 vViewSpacePos;\r\n\r\nvarying vec3 vViewSpaceCenter;\r\n\r\nvarying vec4 vColor;\r\n\r\nvarying float vRadius;\r\n\r\n\r\n\r\n\r\nvoid main(){\r\n\r\nvec4 viewPosHom=uModelViewMatrix*aCenter;\r\nvViewSpaceCenter=viewPosHom.xyz/viewPosHom.w;\r\nvec3 dir=normalize(-vViewSpaceCenter);\r\nvec3 right=normalize(cross(dir,vec3(0,1,0)));\r\nvec3 up=normalize(cross(right,dir));\r\n\r\n\r\nvColor=aColor;\r\nvShininess=aRelativeShininessRadius.z;\r\nvSpecularReflectiveness= (1.0-pow(0.95,vShininess));\r\nvRadius=aRelativeShininessRadius.w;\r\n\r\n\r\nvViewSpacePos=vViewSpaceCenter+\r\nvRadius*(right*aRelativeShininessRadius.x+\r\nup*aRelativeShininessRadius.y+dir);\r\n\r\n\r\ngl_Position=uProjectionMatrix*vec4(vViewSpacePos,1);\r\n}\r\n",
"texq_frag":"precision highp float;\r\n\r\nuniform sampler2D uTexture;\r\nvarying vec2 vPos;\r\n\r\nvoid main(){\r\ngl_FragColor=texture2D(uTexture,vPos);\r\n}\r\n",
"texq_vert":"precision highp float;\r\n\r\nattribute vec4 aPos;\r\nvarying vec2 vPos;\r\n\r\nvoid main(){\r\nvPos=aPos.zw;\r\ngl_Position=vec4(aPos.xy,0,1);\r\n}\r\n",
"triangle_frag":"varying vec4 vPos;\r\nvarying vec4 vNormal;\r\n\r\nuniform bool uTextured;\r\nuniform sampler2D uTexture;\r\n\r\nvoid main(){\r\nif(uTextured)\r\ngColor=texture2DProj(uTexture,vColor.xyz);\r\nelse\r\ngColor=vColor;\r\nfinish(vPos.xyz/vPos.w,normalize(vNormal.xyz));\r\n}\r\n",
"triangle_vert":"uniform mat4 uProjectionMatrix;\r\nuniform mat4 uModelViewMatrix;\r\n\r\nattribute vec4 aPos;\r\nattribute vec4 aNormalAndShininess;\r\nattribute vec4 aColor;\r\n\r\nvarying vec4 vPos;\r\nvarying vec4 vNormal;\r\nvarying vec4 vColor;\r\n\r\nvoid main(){\r\nvPos=uModelViewMatrix*aPos;\r\ngl_Position=uProjectionMatrix*vPos;\r\nvNormal=uModelViewMatrix*vec4(aNormalAndShininess.xyz,0.0);\r\nvShininess=aNormalAndShininess.w;\r\nvSpecularReflectiveness= (1.0-pow(0.95,vShininess));\r\nvColor=aColor;\r\n}\r\n"
};